module Gallina

imports
  Lexical
  Qid
  Options
  extensions/Function

templates // Figure 1.1 of the reference manual 
 
	Term.ForAll   = <forall <Binder+>, <Term>>
	Term.Fun      = [fun [Binder+] => [Term]]
	Term.Fix      = <fix <FixBodies>>
	Term.CoFix    = <cofix <CoFixBodies>>
	Term.Let      = <
	let <Ident><OptBinders><OptType> := 
	  <Term>
	in
	  <Term>
	>
	Term.LetFix   = <let fix <FixBody> in <Term>>
	Term.LetCoFix = <let fix <CoFixBody> in <Term>>
	Term.LetTuple = <let (<Name*; separator=", ">)<OptDepRetType> := <Term> in <Term>>
	Term.LetPat   = <let <SingleQuote> <Pattern><OptInTerm> := <Term><OptReturnType> in <Term>>
	Term.If       = <if <Term><OptDepRetType> then <Term> else <Term>>
		
	Term.Cast     = <<Term> : <Term>>  {non-assoc}
	Term.Check    = [[Term] <: [Term]] {non-assoc}
	Term.Coerce   = [[Term] :>]        {non-assoc}
	Term.Arrow    = [[Term] -> [Term]] {right}
	
	Term.Apply     = <<Term> <Term>> {left, prefer}
	Term.ApplyImplicit = <<Term> <Arg>>
	
	Term.UnHide   = <@<QualId><OptTerms>>

  Term.ScopeRef = <<Term> % <Ident>>
	 
  Term.Match    = <
  match <MatchItem+; separator=", "><OptReturnType> with
    <Equations> end
  >
  
  Term.Ref      = <<QualId>>
  Term          = <<Sort>>
  Term          = <<Num>>
  Term.WldTerm  = <_>

  Term          = <(<Term>)> {bracket}

templates

  Arg.ImplicitArg = <(<Ident> := <Term>)>

templates

  Binder.Bind   = <<Name>>
  Binder.Binds  = <(<Name+; separator=" ">: <Term>)>
  Binder.Assign = <(<Name><OptType> := <Term>)>

templates

  Name          = <<Ident>>
  Name.WldName  = <_>
  
templates
	
	Sort.Prop     = <Prop>
	Sort.Set      = <Set>
	Sort.Type     = <Type>

templates // Auxiliary definitions of figure 1.1

  Equations.ListEqBar  = <
  | <Equation+; separator = "| ">
  >
  Equations.ListEq     = <
  <Equation+; separator = "| ">
  >
  
templates // Figure 1.2 of the reference manual

	FixBodies           = <<FixBody>>
 	FixBodies.With      = <<FixBody> with <FixBody+; separator="with "> for <Ident>>

	FixBody.FixBody     = <
	<Ident> <Binder+; separator=" "><OptAnnotation><OptType> :=
		<Term>
	>

	CoFixBodies         = <<CoFixBody>>
 	CoFixBodies.With    = <<CoFixBody> with <CoFixBody+; separator="with "> for <Ident>>

	CoFixBody.CoFixBody =	<<Ident><OptBinders><OptType> := <Term>>
	
	MatchItem.MatchItem = <<Term><OptAlias><OptInTerm>>
	
	ReturnType.Return    = <return <Term>>

	Equation.Eq        = [
  [MultPattern+; separator=" | "] => [Term]
  
  ]
	
	MultPattern        = <<Pattern+; separator=", ">>
	
	Pattern.QidPattern = <<QualId> <Pattern+; separator=" ">>
	Pattern.AsPattern  = <<Pattern> as <Ident>>
	Pattern.XPattern   = <<Pattern> % <Ident>>
	Pattern            = <<QualId>>
	Pattern.Wld        = <_>
	Pattern            = <<Num>>
	Pattern.OrPattern  = <(<OrPattern+; separator=", ">)>
	
	OrPattern          = <<Pattern+; separator=" | ">>
	
templates // Common notational extensions

  Term.List  = <[<Term*; separator=";">]>
  Term.Tuple = <(<Term>,<Term+; separator=",">)>
  
  Term.Prod  = <<Term> * <Term>>  {left}
  Term.Eq    = <<Term> = <Term>>  {non-assoc}
  Term.NotE  = [[Term] <> [Term]] {non-assoc}
  Term.And   = <<Term> /\ <Term>>

context-free priorities

  Term.ForAll > Term.Apply > Term.Arrow > Term.Prod > {non-assoc: Term.Check Term.Cast Term.Coerce Term.Eq Term.NotE} > Term.And

templates // 2.1 Used in records:

  Type = <<Term>>

	