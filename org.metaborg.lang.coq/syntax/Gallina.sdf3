module Gallina

imports Lexical Qid

templates // Figure 1.1 of the reference manual 
 
	STerm.ForAll   = <forall <Binder+>, <Term>>
	STerm.Fun      = [fun [Binder+] => [Term]]
	STerm.Fix      = <fix <FixBodies>>
	STerm.CoFix    = <cofix <CoFixBodies>>
	STerm.Let      = <
	let <Ident><OptBinders><OptType> := 
	  <Term>
	in
	  <Term>
	>
	STerm.LetFix   = <let fix <FixBody> in <Term>>
	STerm.LetCoFix = <let fix <CoFixBody> in <Term>>
	STerm.LetTuple = <let (<Name*; separator=", ">)<OptDepRetType> := <Term> in <Term>>
	STerm.LetPat   = <let <SingleQuote> <Pattern><OptInTerm> := <Term><OptReturnType> in <Term>>
	STerm.If       = <if <Term><OptDepRetType> then <Term> else <Term>>
		
	STerm.Cast     = <<Term> : <Term>>  {non-assoc}
	STerm.Check    = [[Term] <: [Term]] {non-assoc}
	STerm.Coerce   = [[Term] :>]        {non-assoc}
	STerm.Arrow    = [[Term] -> [Term]] {right}
	
	Term.Apply     = <<STerm> <Arg+>> {left, prefer}
	Term           = <<STerm>>
	
	STerm.UnHide   = <@<QualId><OptTerms>>

  STerm.ScopeRef = <<Term> % <Ident>>
	 
  STerm.Match    = <
  match <MatchItem+; separator=", "><OptReturnType> with
    <Equations> end
  >
  
  STerm.Ref      = <<QualId>>
  STerm.Sort     = <<Sort>>
  STerm.Num      = <<Num>>
  STerm.WldTerm  = <_>

  STerm          = <(<Term>)> {bracket}

templates

  Arg.ImplicitArg = <(<Ident> := <Term>)>
  Arg             = <<STerm>>

templates

  Binder.Bind   = <<Name>>
  Binder.Binds  = <(<Name+; separator=" ">: <Term>)>
  Binder.Assign = <(<Name><OptType> := <Term>)>

templates

  Name          = <<Ident>>
  Name.WldName  = <_>
  
templates
	
	Sort.Prop     = <Prop>
	Sort.Set      = <Set>
	Sort.Type     = <Type>

templates // Auxiliary definitions of figure 1.1

  Equations.ListEqBar  = <
  | <Equation+; separator = "| ">
  >
  Equations.ListEq     = <
  <Equation+; separator = "| ">
  >
  
templates // Options

  OptType.None         = <>
  OptType.Type         = < : <Term>>
  
  OptInTerm.None       = <>
  OptInTerm.In         = < in <Term>>
  
  OptDepRetType.None   = <>
  OptDepRetType.DepRet = <<OptAlias> <ReturnType>>
  
  OptAlias.None        = <>
  OptAlias.As          = < as <Name>>
  
  OptReturnType.None   = <>
  OptReturnType        = < <ReturnType>>
  
  OptBinders.None      = <>
  OptBinders           = < <Binder+; separator=" ">>
  
  OptTerms.None        = <>
  OptTerms             = < <Term+; separator=" ">>
  
templates // Figure 1.2 of the reference manual

	FixBodies           = <<FixBody>>
 	FixBodies.With      = <<FixBody> with <FixBody+; separator="with "> for <Ident>>

	FixBody.FixBody     = <
	<Ident> <Binder+; separator=" "><OptAnnotation><OptType> :=
		<Term>
	>

	CoFixBodies         = <<CoFixBody>>
 	CoFixBodies.With    = <<CoFixBody> with <CoFixBody+; separator="with "> for <Ident>>

	CoFixBody.CoFixBody =	<<Ident><OptBinders><OptType> := <Term>>

	OptAnnotation.None  = <>
	OptAnnotation.Anno  = < { struct <Ident> }>
	
	MatchItem.MatchItem = <<Term><OptAlias><OptInTerm>>
	
	ReturnType.Return    = <return <Term>>

	Equation.Eq        = [
  [MultPattern+; separator=" | "] => [Term]
  
  ]
	
	MultPattern        = <<Pattern+; separator=", ">>
	
	Pattern.QidPattern = <<QualId> <Pattern+; separator=" ">>
	Pattern.AsPattern  = <<Pattern> as <Ident>>
	Pattern.XPattern   = <<Pattern> % <Ident>>
	Pattern            = <<QualId>>
	Pattern.Wld        = <_>
	Pattern            = <<Num>>
	Pattern.OrPattern  = <(<OrPattern+; separator=", ">)>
	
	OrPattern          = <<Pattern+; separator=" | ">>
	
templates // Extensions

  STerm.List  = <[<Term*; separator=";">]>
  STerm.Tuple = <(<Term>,<Term+; separator=",">)>
  
  STerm.Prod  = <<Term> * <Term>>  {left}
  STerm.Eq    = <<Term> = <Term>>  {non-assoc}
  STerm.NotE  = [[Term] <> [Term]] {non-assoc}

context-free priorities

  Term.Apply > STerm.Arrow > STerm.Prod > {non-assoc: STerm.Check STerm.Cast STerm.Coerce STerm.Eq STerm.NotE}

	